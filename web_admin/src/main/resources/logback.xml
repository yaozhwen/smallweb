<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <property resource="application.properties" />
    <property name="log.root.level" value="${logging.smallweb.level}" />
    <property name="log.other.level" value="${logging.smallweb.level}" />
    <property name="log.base" value="${logging.smallweb.file}" />
    <property name="log.moduleName" value="${logging.smallweb.moduleName}" />
    <property name="log.max.size" value="100MB" />
    <property name="springAppName" value="${spring.application.name}" />

    <!--{
    "timestamp": "%d{yyyy-MM-dd HH:mm:ss.SSS}",
    "level": "%level",
    "service_id": "${springAppName:-}",
    "trace": "%X{X-B3-TraceId:-}",
    "span": "%X{X-B3-SpanId:-}",
    "exportable": "%X{X-Span-Export:-}",
    "pid": "${PID:-}",
    "thread": "%thread",
    "class": "%logger{40}",
    "line_number": "%line",
    "stack_trace": "%exception{5}",
    "message": "%message"
    }-->

    <!--控制台输出 -->
    <appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%msg%n</Pattern>
            <charset class="java.nio.charset.Charset">UTF-8</charset>
        </encoder>
        <!--<layout class="com.yao.core.util.MyPatternLayout">-->
            <!--<Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%smallweb%n</Pattern>-->
        <!--</layout>-->
    </appender>

    <!-- 用来保存输出所有级别的日志 -->
    <appender name="file.all" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <File>${log.base}/${log.moduleName}.log</File><!-- 设置日志不超过${log.max.size}时的保存路径，注意如果
            是web项目会保存到Tomcat的bin目录 下 -->
        <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${log.base}/archive/${log.moduleName}_all_%d{yyyy-MM-dd}.%i.log</FileNamePattern>
            <!-- 文件输出日志 (文件大小策略进行文件输出，超过指定大小对文件备份) -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>${log.max.size}</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%msg%n</Pattern>
            <charset class="java.nio.charset.Charset">UTF-8</charset>
        </encoder>
        <!--<layout class="com.yao.core.util.MyPatternLayout">
            <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%smallweb%n</Pattern>
        </layout>-->
    </appender>

    <!-- 只用保存输出error级别的日志 -->
    <appender name="file.error" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <File>${log.base}/${log.moduleName}.errlog</File>
        <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${log.base}/archive/${log.moduleName}_%d{yyyy-MM-dd}.%i.errlog</FileNamePattern>
            <!-- 文件输出日志 (文件大小策略进行文件输出，超过指定大小对文件备份) -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>${log.max.size}</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%msg%n</Pattern>
            <charset class="java.nio.charset.Charset">UTF-8</charset>
        </encoder>
        <!--<layout class="com.yao.core.util.MyPatternLayout">-->
            <!--<Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} ${springAppName:-} traceId=%X{X-B3-TraceId:-} SpanId=%X{X-B3-SpanId:-} %-5level[%thread]%logger{56}.%method:%L -%smallweb%n</Pattern>-->
        <!--</layout>-->
        <!-- 下面为配置只输出error级别的日志 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
    <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
    <!-- 添加附加的appender,最多只能添加一个 -->
    <appender name="file.async" class="ch.qos.logback.classic.AsyncAppender">
        <discardingThreshold>0</discardingThreshold>
        <queueSize>256</queueSize>
        <includeCallerData>true</includeCallerData>
        <appender-ref ref="file.all" />
    </appender>

    <logger name="org.springframework" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="org.apache" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="com.netflix" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="o.hibernate" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="org.hibernate" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="o.h.v.i.engine" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>
    <logger name="org.crazycake.shiro.RedisSessionDAO" additivity="false">
        <level value="ERROR" />
        <appender-ref ref="stdout" />
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </logger>

    <!-- root将级别为${log.root.level}及大于${log.root.level}的日志信息交给已经配置好的名为“Console”的appender处理，“Console”appender将信息打印到Console,其它同理 -->
    <root level="${log.root.level}">
        <appender-ref ref="stdout" /> <!--  标识这个appender将会添加到这个logger -->
        <appender-ref ref="file.async" />
        <appender-ref ref="file.error" />
    </root>
</configuration>